{
  "version": "2026-02-28.16",
  "updated_at": "2026-02-28T22:15:00Z",
  "owners": [
    "enceladus-platform"
  ],
  "backward_compatibility_policy": "Additive changes are preferred. Removing enum values or required fields requires explicit migration notes and coordinated rollout.",
  "entities": {
    "tracker.task": {
      "description": "Task tracker records created via MCP and tracker mutation APIs.",
      "fields": {
        "status": {
          "type": "enum",
          "enum": ["open", "in-progress", "coding-complete", "committed", "pushed", "merged-main", "deployed", "closed"],
          "definition": "Task lifecycle status.",
          "usage_guidance": "Task transitions are sequential; use tracker_validation_rules before tracker_set to obtain required evidence and checkout requirements."
        },
        "priority": {
          "type": "enum",
          "enum": ["P0", "P1", "P2", "P3"],
          "definition": "Task urgency classification."
        },
        "category": {
          "type": "enum",
          "enum": ["implementation", "investigation", "documentation", "maintenance", "validation"],
          "definition": "Task category used for governance and reporting."
        },
        "acceptance_criteria": {
          "type": "array",
          "item_type": "string",
          "constraints": {"min_items": 1},
          "definition": "Concrete conditions to mark task complete.",
          "usage_guidance": "Required for task creation."
        },
        "coordination": {
          "type": "boolean",
          "definition": "Whether task is created under coordination workflow."
        },
        "transition_evidence": {
          "type": "object",
          "definition": "Evidence payload required for gated status transitions.",
          "usage_guidance": "task->pushed requires commit_sha; task->merged-main requires merge_evidence; task->deployed requires deployment_ref; any revert requires revert_reason."
        }
      }
    },
    "tracker.issue": {
      "description": "Issue tracker records for bug/risk/debt/security/performance.",
      "fields": {
        "status": {
          "type": "enum",
          "enum": ["open", "in-progress", "closed"]
        },
        "priority": {
          "type": "enum",
          "enum": ["P0", "P1", "P2", "P3"]
        },
        "category": {
          "type": "enum",
          "enum": ["bug", "debt", "risk", "security", "performance"]
        },
        "evidence": {
          "type": "array",
          "item_type": "object",
          "constraints": {"min_items": 1, "required_keys": ["description", "steps_to_duplicate"]},
          "usage_guidance": "Issue creation requires at least one evidence object."
        }
      }
    },
    "tracker.feature": {
      "description": "Feature tracker records with governed completion handshake.",
      "fields": {
        "status": {
          "type": "enum",
          "enum": ["planned", "in-progress", "completed", "production", "deprecated"]
        },
        "priority": {
          "type": "enum",
          "enum": ["P0", "P1", "P2", "P3"]
        },
        "category": {
          "type": "enum",
          "enum": ["epic", "capability", "enhancement", "infrastructure"]
        },
        "user_story": {
          "type": "string",
          "constraints": {"min_length": 10},
          "usage_guidance": "Must follow: As a [USER/SYSTEM] I need/want ... so that ..."
        },
        "acceptance_criteria": {
          "type": "array",
          "item_type": "object|string",
          "constraints": {"min_items": 1},
          "usage_guidance": "Feature completion requires accepted evidence for all criteria."
        }
      }
    },
    "document.create": {
      "description": "Agent document create payload fields.",
      "fields": {
        "project_id": {
          "type": "string",
          "constraints": {"pattern": "^[a-z0-9_-]+$"}
        },
        "title": {
          "type": "string",
          "constraints": {"min_length": 1, "max_length": 500}
        },
        "content": {
          "type": "string",
          "constraints": {"min_length": 1, "max_bytes": 1048576}
        },
        "file_name": {
          "type": "string",
          "constraints": {"extensions": [".md", ".markdown"]}
        },
        "keywords": {
          "type": "array",
          "item_type": "string",
          "constraints": {"max_items": 50}
        },
        "related_items": {
          "type": "array",
          "item_type": "string",
          "constraints": {"max_items": 100}
        }
      }
    },
    "document.query_response": {
      "description": "Document list/search response envelope fields returned by document_api.",
      "fields": {
        "documents": {
          "type": "array",
          "item_type": "object",
          "definition": "Document metadata records for list/search results."
        },
        "count": {
          "type": "number",
          "definition": "Number of documents returned in current page/response."
        },
        "total_matches": {
          "type": "number",
          "definition": "Total matching documents before response slicing."
        }
      }
    },
    "deploy.request": {
      "description": "Deployment intake request schema for /api/v1/deploy.",
      "fields": {
        "change_type": {
          "type": "enum",
          "enum": ["patch", "minor", "major"]
        },
        "deployment_type": {
          "type": "enum",
          "enum": [
            "github_public_static",
            "github_private_sst",
            "github_public_workers",
            "github_private_workers",
            "lambda_update",
            "lambda_layer",
            "container_template",
            "glue_crawler_update",
            "glue_job_update",
            "eventbridge_rule",
            "s3_asset_sync",
            "cloudfront_config",
            "step_function_update"
          ]
        },
        "summary": {
          "type": "string",
          "constraints": {"min_length": 1}
        },
        "changes": {
          "type": "array",
          "item_type": "string",
          "constraints": {"min_items": 1}
        },
        "project_id": {
          "type": "string",
          "constraints": {"pattern": "^[a-z0-9_-]+$"}
        }
      }
    },
    "coordination.request": {
      "description": "Coordination request envelope fields in coordination API.",
      "fields": {
        "state": {
          "type": "enum",
          "enum": [
            "intake_received",
            "queued",
            "dispatching",
            "running",
            "succeeded",
            "failed",
            "cancelled",
            "dead_letter"
          ]
        },
        "execution_mode": {
          "type": "enum",
          "enum": [
            "preflight",
            "codex_full_auto",
            "codex_app_server",
            "claude_headless",
            "claude_agent_sdk",
            "aws_step_function"
          ]
        },
        "provider": {
          "type": "enum",
          "enum": ["openai_codex", "claude_agent_sdk", "aws_native", "aws_bedrock_agent"]
        },
        "dispatch.prompt_submitted": {
          "type": "string",
          "definition": "Prompt text submitted to provider runtime and persisted for execution traceability."
        },
        "session_archive_turn_index": {
          "type": "number",
          "definition": "Monotonic request-local turn counter used to assign deterministic archive turn IDs."
        },
        "result.details.session_archive": {
          "type": "object",
          "definition": "Archive write outcome metadata emitted by refresh polling for codex execution modes.",
          "usage_guidance": "Contains archived(bool), key, records, redaction_hits and fallback buffered_path when S3 writes fail."
        },
        "skip_debounce": {
          "type": "boolean",
          "definition": "When true, bypasses the 3-minute debounce window and auto-promotes request from intake_received to queued with immediate dispatch.",
          "usage_guidance": "Used by chat message endpoint (POST /sessions/{id}/message) for interactive terminal sessions."
        },
        "provider_session": {
          "type": "object",
          "definition": "Session context for multi-turn terminal interactions.",
          "usage_guidance": "Contains session_id and thread_id. Used to group coordination requests into logical terminal sessions."
        }
      }
    },
    "coordination.session": {
      "description": "Derived session view aggregated from coordination requests grouped by provider_session.session_id.",
      "fields": {
        "session_id": {
          "type": "string",
          "definition": "UUID identifying the terminal session."
        },
        "provider": {
          "type": "enum",
          "enum": ["openai_codex", "claude_agent_sdk", "unknown"],
          "definition": "Provider derived from execution_mode of session requests."
        },
        "is_active": {
          "type": "boolean",
          "definition": "True if the latest request in the session is in a non-terminal state."
        },
        "turn_count": {
          "type": "number",
          "definition": "Number of coordination requests associated with this session."
        }
      }
    },
    "coordination.auth_cognito_session": {
      "description": "Payload contract for Cognito terminal-session bootstrap used by protected PWA diagnostics (POST /api/v1/coordination/auth/cognito/session and MCP tool coordination_cognito_session).",
      "fields": {
        "target_origin": {
          "type": "string",
          "constraints": {"format": "https-origin"},
          "usage_guidance": "Must be an https origin matching the target Enceladus host where cookies will be applied."
        },
        "include_set_cookie_headers": {
          "type": "boolean",
          "usage_guidance": "When true, response includes serialized Set-Cookie strings for non-browser tooling."
        },
        "include_tokens": {
          "type": "boolean",
          "usage_guidance": "When true, response includes raw Cognito tokens. Use only for controlled diagnostics because token material is sensitive."
        },
        "session.cookies": {
          "type": "array",
          "item_type": "object",
          "usage_guidance": "Canonical cookie objects returned by coordination API, including id token, refresh token (when available), and session timestamp cookie."
        },
        "session.playwright_cookies": {
          "type": "array",
          "item_type": "object",
          "usage_guidance": "Browser-context cookie entries consumable by Playwright automation for authenticated evidence capture."
        },
        "session.set_cookie_headers": {
          "type": "array",
          "item_type": "string",
          "usage_guidance": "Optional serialized Set-Cookie header values for external HTTP clients."
        },
        "session.tokens": {
          "type": "object",
          "usage_guidance": "Optional raw token object (id/access/refresh) returned only when include_tokens=true."
        }
      }
    },
    "internal_auth.scope_map": {
      "description": "Scoped service-token authorization map shared across Enceladus service APIs.",
      "fields": {
        "COORDINATION_INTERNAL_API_KEY": {
          "type": "string",
          "usage_guidance": "Primary shared internal key. Services normalize non-empty fallback across aliases: ENCELADUS_COORDINATION_API_INTERNAL_API_KEY, ENCELADUS_COORDINATION_INTERNAL_API_KEY, COORDINATION_INTERNAL_API_KEY."
        },
        "COORDINATION_INTERNAL_API_KEY_PREVIOUS": {
          "type": "string",
          "usage_guidance": "Optional rollover key. Services normalize non-empty fallback across aliases: ENCELADUS_COORDINATION_API_INTERNAL_API_KEY_PREVIOUS, ENCELADUS_COORDINATION_INTERNAL_API_KEY_PREVIOUS, COORDINATION_INTERNAL_API_KEY_PREVIOUS."
        },
        "COORDINATION_INTERNAL_API_KEY_SCOPES": {
          "type": "object",
          "constraints": {
            "format": "json-map",
            "key": "internal token or * wildcard",
            "value": "array|string of lowercase scopes"
          },
          "usage_guidance": "Accepted by project_service, tracker_mutation, document_api, and deploy_intake. Supports exact scopes (for example deploy:write), prefix wildcards (for example tracker:*), and global values (* or all)."
        },
        "required_scopes": {
          "type": "object",
          "constraints": {
            "method_map": {
              "project_service": {
                "GET": "projects:read",
                "POST": "projects:write"
              },
              "tracker_mutation": {
                "GET": "tracker:read",
                "POST|PATCH|DELETE": "tracker:write"
              },
              "document_api": {
                "GET": "documents:read",
                "PUT|POST|PATCH": "documents:write"
              },
              "deploy_intake": {
                "GET": "deploy:read",
                "POST|PATCH": "deploy:write"
              }
            }
          },
          "usage_guidance": "If scope map is omitted, internal keys remain permissive for backward compatibility."
        }
      }
    },
    "governance.resource": {
      "description": "Governance files accessible via governance_get MCP tool and governance_update API.",
      "fields": {
        "file_name": {
          "type": "string",
          "enum": ["agents.md", "governance_data_dictionary.json"],
          "usage_guidance": "Recognized governance file names. 'agents.md' and files under 'agents/' are Markdown governance rules. 'governance_data_dictionary.json' is the machine-readable schema/enum dictionary; load at session init via governance_get(\"governance_data_dictionary.json\")."
        },
        "uri": {
          "type": "string",
          "usage_guidance": "Resolved as governance://{file_name}. Only registered file_names are valid; others return NOT_FOUND."
        }
      }
    },
    "internal_auth.managed_token": {
      "description": "Unified service authentication token records stored by coordination API for external service integrations.",
      "fields": {
        "policy_id": {
          "type": "string",
          "constraints": {"prefix": "service_token#"},
          "usage_guidance": "Deterministic key built from sha256(token) to avoid storing plaintext token secrets."
        },
        "token_id": {
          "type": "string",
          "constraints": {"pattern": "^TOK-[A-Z0-9]{12}$"},
          "usage_guidance": "Operator-facing token identifier used for delete/permissions update routes."
        },
        "service_name": {
          "type": "string",
          "constraints": {"min_length": 1},
          "usage_guidance": "Human-readable external service label shown in Tokens/Permissions UI tabs."
        },
        "permissions": {
          "type": "array",
          "item_type": "enum",
          "enum": ["read", "write", "put", "delete", "admin"],
          "usage_guidance": "Cross-service grant set used by unified auth model."
        },
        "status": {
          "type": "enum",
          "enum": ["active", "revoked"]
        },
        "token_masked": {
          "type": "string",
          "usage_guidance": "Obfuscated display value for UI listing; plaintext token is returned only at creation."
        },
        "created_at": {"type": "timestamp"},
        "updated_at": {"type": "timestamp"},
        "last_used_at": {"type": "timestamp"}
      }
    },
    "mcp_server.oauth_token": {
      "description": "OAuth 2.1 token parameters issued by the enceladus-mcp-streamable Lambda's token endpoint. Governs how the MCP server authenticates Claude.ai connectors (web, mobile, desktop) and how long sessions persist without user re-authentication.",
      "fields": {
        "access_token": {
          "type": "string",
          "usage_guidance": "Equals MCP_API_KEY env var. Stateless — no server-side token storage. Validated by the Lambda handler on every request via exact Bearer comparison."
        },
        "token_type": {
          "type": "enum",
          "enum": ["bearer"],
          "usage_guidance": "Always 'bearer'. Sent by clients as Authorization: Bearer <access_token>."
        },
        "expires_in": {
          "type": "number",
          "constraints": {"min": 1},
          "usage_guidance": "Access token lifetime in seconds. Configurable via ENCELADUS_MCP_TOKEN_TTL env var. Default 28800 (8 hours). Controls when Claude.ai will attempt to use the refresh token."
        },
        "refresh_token": {
          "type": "string",
          "usage_guidance": "Self-contained HMAC-signed opaque token with 30-day TTL. Format: base64url(payload).sha256hex. Payload is {typ:'rt', iat:<unix>, exp:<unix+2592000>} signed with OAUTH_CLIENT_SECRET. Stateless — no server storage required; valid across Lambda cold starts. Issued only on authorization_code grant (not client_credentials per RFC 6749 §4.4.3). Rotated on every use."
        },
        "grant_types_supported": {
          "type": "array",
          "item_type": "enum",
          "enum": ["authorization_code", "refresh_token", "client_credentials"],
          "usage_guidance": "Advertised in /.well-known/oauth-authorization-server metadata. authorization_code (with PKCE/S256) is the primary flow for Claude.ai connectors. refresh_token enables silent renewal without user interaction. client_credentials is available for programmatic access."
        },
        "ENCELADUS_MCP_TOKEN_TTL": {
          "type": "number",
          "constraints": {"min": 300},
          "usage_guidance": "Lambda env var controlling access token lifetime in seconds. Default 28800 (8h). Set to shorter values for higher-security environments. Do not set below 300s — shorter values increase re-auth noise without meaningful security benefit."
        }
      }
    }
  }
}
